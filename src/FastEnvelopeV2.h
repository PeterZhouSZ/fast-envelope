#pragma once
#include <fastenvelope/Types.hpp>
#include<vector>
#include<fastenvelope/Parameters.h>
#include <fenv.h>
namespace fastEnvelope {
	

	class FastEnvelope
	{
	public:
		
		static bool FastEnvelopeTest(const std::array<Vector3, 3> &triangle, const std::vector<std::array<Vector3, 12>>& envprism);
		static bool FastEnvelopeTestTemp(const std::array<Vector3, 3> &triangle, const std::vector<std::array<Vector3, 12>>& envprism);
		static bool FastEnvelopeTestImplicit(const std::array<Vector3, 3> &triangle, const std::vector<std::array<Vector3, 12>>& envprism);
		static void SLIntersection(const Parameters &params, const std::array<Vector3, 3>& cutface, const Vector3& linepoints0, const Vector3& linepoints1,
			int & cutOrnot, Vector3& interp);
		// segment and facet intersection. the first 3 segments are triangle edges. interp is the list of intersection points GENERATED BY THIS CUT, 
		//interseg shows this interp is generated by which segment
		static void Segment_facet_intersection(std::vector<std::array<Vector3, 2>>& seglist, const std::array<Vector3, 3>& facet, std::vector<Vector3>& interp, std::vector<int>& interseg);
		//static void Segment_facet_intersectionV2(std::vector<std::array<Vector3, 2>>& seglist, const std::array<Vector3, 3>& facet, std::vector<Vector3>& interp, std::vector<int>& interseg);
		// to check if a point is in the prisms. the jump index shows the prisms not counted in calculation, and jump is sorted from small to big
		static bool point_out_prism(const Vector3& point, const std::vector<std::array<Vector3, 12>>& envprism, const std::vector<int>& jump);

		static void BoxGeneration(const std::vector<Vector3>& m_ver, const std::vector<Vector3i>& m_faces, std::vector<std::array<Vector3, 12>>& envprism, const Scalar& bbd);
		static int orient_3triangles(const Eigen::Matrix<Scalar, 3, 3>& A,const Eigen::Matrix<Scalar, 3, 3>& AT,
			const Eigen::Matrix<Scalar, 3, 3>& ATA,const Eigen::Matrix<Scalar, 3, 1>& B, const std::array<Vector3, 3> & triangle3);
		static int Implicit_Seg_Facet_interpoint_Out_Prism(const Vector3& segpoint0, const Vector3& segpoint1, const std::array<Vector3, 3>& triangle,
			const std::vector<std::array<Vector3, 12>>& envprism,const std::vector<int>& jump);
		static int Implicit_Seg_Facet_interpoint_Out_Prism_Wang(const Vector3& segpoint0, const Vector3& segpoint1, const std::array<Vector3, 3>& triangle,
			const std::vector<std::array<Vector3, 12>>& envprism, const std::vector<int>& jump);
		static int Implicit_Tri_Facet_Facet_interpoint_Out_Prism( const std::array<Vector3, 3>& triangle, const std::array<Vector3, 3>& facet1, const std::array<Vector3, 3>& facet2,
			const std::vector<std::array<Vector3, 12>>& envprism, const std::vector<int>& jump);
		static bool is_seg_facet_intersection(const double& px, const double& py, const double& pz,
			const double& qx, const double& qy, const double& qz,
			const double& rx, const double& ry, const double& rz,
			const double& sx, const double& sy, const double& sz,
			const double& tx, const double& ty, const double& tz,
			double& a11, double& a12, double& a13,
			double& a21, double& a22, double& a23,
			double& a31, double& a32, double& a33,
			double& px_rx, double& py_ry, double& pz_rz,
			double& d, double& n);
		static bool is_seg_facet_intersection_Wang(const Vector3& seg0, const Vector3& seg1, const std::array<Vector3, 3>& triangle, Scalar& d, Scalar&n);
		static int Orient_LPI_Wang(const Vector3& seg0, const Vector3& seg1, Scalar& d, Scalar&n, const std::array<Vector3, 3>& facet);
		static void timerecord();

		static int tri_cut_tri_simple(const Vector3& p1, const Vector3& p2, const Vector3& p3,const Vector3& q1, const Vector3& q2, const Vector3& q3);
	// Indirect 3D orientation predicate with floating point filter.
	//
	// Input: eight points p, q, r, s, t, a, b, c
	// where:
	// <p, q> define a straight line L
	// <r, s, t> define a plane P1
	// <a, b, c> define a plane P2
	//
	// Output:
	// Let i be the exact intersection point between L and P1.
	// orient3D_LPI returns 1 if the tetrahedron (i, a, b, c) has positive volume.
	// Returns -1 if it has negative volume.
	// Zero is returned if one of the following conditions holds:
	// - degenerate input (L and P1 are parallel, <r, s, t> are collinear, ...)
	// - i is exactly on P2
	// - the floating point precision is insufficient to guarantee an exact answer
	// - the input coordinates cause an under/overflow during the computation.

		static inline int orient3D_LPI_Modified(const std::array<Vector3,2>& pq,
			const std::array<Vector3, 3>& rst,
			const std::array<Vector3, 3>& abc )
		{
			::feclearexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID);

			Scalar a11, a12, a13, a21, a22, a23, a31, a32, a33;
			Scalar px_rx, py_ry, pz_rz;
			Scalar a2233, a2133, a2132;
			Scalar d, n;
			Scalar ix, iy, iz;
			Scalar m12, m13, m14, m23, m24, m34;
			Scalar m123, m124, m134, m234;
			Scalar det4x4_return_value;

			a11 = (pq[0][0] - pq[1][0]);
			a12 = (pq[0][1] - pq[1][1]);
			a13 = (pq[0][2] - pq[1][2]);
			a21 = (rst[1][0] - rst[0][0]);
			a22 = (rst[1][1] - rst[0][1]);
			a23 = (rst[1][2] - rst[0][2]);
			a31 = (rst[2][0] - rst[0][0]);
			a32 = (rst[2][1] - rst[0][1]);
			a33 = (rst[2][2] - rst[0][2]);
			px_rx = pq[0][0] - rst[0][0];
			py_ry = pq[0][1] - rst[0][1];
			pz_rz = pq[0][2] - rst[0][2];
			a2233 = ((a22 * a33) - (a23 * a32));
			a2133 = ((a21 * a33) - (a23 * a31));
			a2132 = ((a21 * a32) - (a22 * a31));
			d = (((a11 * a2233) - (a12 * a2133)) + (a13 * a2132));
			n = ((((py_ry)* a2133) - ((px_rx)* a2233)) - ((pz_rz)* a2132));
			ix = ((d * pq[0][0]) + (a11 * n));
			iy = ((d * pq[0][1]) + (a12 * n));
			iz = ((d * pq[0][2]) + (a13 * n));
			m12 = (((d * abc[0][0]) * iy) - (ix * (d * abc[0][1])));
			m13 = (((d * abc[1][0]) * iy) - (ix * (d * abc[1][1])));
			m14 = (((d * abc[2][0]) * iy) - (ix * (d * abc[2][1])));
			m23 = (((d * abc[1][0]) * (d * abc[0][1])) - ((d * abc[0][0]) * (d * abc[1][1])));
			m24 = (((d * abc[2][0])) * (d * abc[0][1])) - ((d * abc[0][0]) * (d * abc[2][1]));
			m34 = (((d * abc[2][0])) * (d * abc[1][1])) - ((d * abc[1][0]) * (d * abc[2][1]));
			m123 = (((m23 * iz) - (m13 * (d * abc[0][2]))) + (m12 * (d * abc[1][2])));
			m124 = (((m24 * iz) - (m14 * (d * abc[0][2]))) + (m12 * (d * abc[2][2])));
			m134 = (((m34 * iz) - (m14 * (d * abc[1][2]))) + (m13 * (d * abc[2][2])));
			m234 = (((m34 * (d * abc[0][2])) - (m24 * (d * abc[1][2]))) + (m23 * (d * abc[2][2])));
			det4x4_return_value = (m234 - m134 + m124 - m123)*d;
			if (::fetestexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)) return 0; // Fast reject in case of under/overflow


			// Almost static filter
			Scalar fa11 = fabs(a11);
			Scalar fa21 = fabs(a21);
			Scalar fa31 = fabs(a31);
			Scalar fa12 = fabs(a12);
			Scalar fa22 = fabs(a22);
			Scalar fa32 = fabs(a32);
			Scalar fa13 = fabs(a13);
			Scalar fa23 = fabs(a23);
			Scalar fa33 = fabs(a33);
			Scalar fax = fabs(abc[0][0]);
			Scalar fay = fabs(abc[0][1]);
			Scalar faz = fabs(abc[0][2]);
			Scalar fbx = fabs(abc[1][0]);
			Scalar fby = fabs(abc[1][1]);
			Scalar fbz = fabs(abc[1][2]);
			Scalar fcx = fabs(abc[2][0]);
			Scalar fcy = fabs(abc[2][1]);
			Scalar fcz = fabs(abc[2][2]);
			Scalar fpxrx = fabs(px_rx);
			Scalar fpyry = fabs(py_ry);
			Scalar fpzrz = fabs(pz_rz);

			Scalar max1, max2, max3, max4, max5, max6, max7, max8;
			max4 = fa11;
			if (max4 < fa31) max4 = fa31;
			if (max4 < fa21) max4 = fa21;
			max5 = max4;
			if (max5 < fpxrx)  max5 = fpxrx;
			max1 = max5;
			if (max1 < fbx) max1 = fbx;
			if (max1 < fax) max1 = fax;
			if (max1 < fcx) max1 = fcx;
			max2 = fbz;
			if (max2 < faz) max2 = faz;
			if (max2 < fcz) max2 = fcz;
			if (max2 < fa13) max2 = fa13;
			max6 = fa12;
			if (max6 < fa22) max6 = fa22;
			if (max6 < fa32) max6 = fa32;
			max3 = max6;
			if (max3 < fay) max3 = fay;
			if (max3 < fcy) max3 = fcy;
			if (max3 < fby) max3 = fby;
			if (max3 < fpyry) max3 = fpyry;
			max7 = fa13;
			if (max7 < fa23) max7 = fa23;
			if (max7 < fa33) max7 = fa33;
			max8 = max7;
			if (max8 < fpzrz) max8 = fpzrz;

			Scalar eps = 3.53761371545404460000e-011 * max6 * max7 * max4 * max1 * max6 * max7 * max4 * max3 * max3 * max8 * max5 * max2;
			if ((det4x4_return_value > eps)) return -1;
			else if ((det4x4_return_value < -eps)) return 1;
			else return 0;
		}


		// Indirect 3D orientation predicate with floating point filter.
		//
		// Input: eight points p, q, r, s, t, a, b, c
		// where:
		// <p, q> define a straight line L
		// <r, s, t> define a plane P1
		// <a, b, c> define a plane P2
		//
		// Output:
		// Let i be the exact intersection point between L and P1.
		// orient3D_LPI returns 1 if the tetrahedron (i, a, b, c) has positive volume.
		// Returns -1 if it has negative volume.
		// Zero is returned if one of the following conditions holds:
		// - degenerate input (L and P1 are parallel, <r, s, t> are collinear, ...)
		// - i is exactly on P2
		// - the floating point precision is insufficient to guarantee an exact answer
		// - the input coordinates cause an under/overflow during the computation.

		static inline int orient3D_LPI(//right hand law
			const double& px, const double& py, const double& pz,
			const double& ax, const double& ay, const double& az,
			const double& bx, const double& by, const double& bz,
			const double& cx, const double& cy, const double& cz,
			const double& a11, const double& a12, const double& a13,
			const double& a21, const double& a22, const double& a23,
			const double& a31, const double& a32, const double& a33,
			const double& px_rx, const double& py_ry, const double& pz_rz,
			const double& d, const double& n)
		{
			::feclearexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID);

			
			double dax, day, daz, dbx, dby, dbz, dcx, dcy, dcz;
			double ix, iy, iz;
			double m12, m13, m14, m23, m24, m34;
			double m123, m124, m134, m234;
			double det4x4_return_value;

			
			ix = ((d * px) + (a11 * n));
			iy = ((d * py) + (a12 * n));
			iz = ((d * pz) + (a13 * n));
			dax = d * ax;
			day = d * ay;
			daz = d * az;
			dbx = d * bx;
			dby = d * by;
			dbz = d * bz;
			dcx = d * cx;
			dcy = d * cy;
			dcz = d * cz;
			m12 = ((dax * iy) - (ix * day));
			m13 = ((dbx * iy) - (ix * dby));
			m14 = ((dcx * iy) - (ix * dcy));
			m23 = ((dbx * day) - (dax * dby));
			m24 = ((dcx * day) - (dax * dcy));
			m34 = ((dcx * dby) - (dbx * dcy));
			m123 = (((m23 * iz) - (m13 * daz)) + (m12 * dbz));
			m124 = (((m24 * iz) - (m14 * daz)) + (m12 * dcz));
			m134 = (((m34 * iz) - (m14 * dbz)) + (m13 * dcz));
			m234 = (((m34 * daz) - (m24 * dbz)) + (m23 * dcz));
			det4x4_return_value = (m234 - m134 + m124 - m123);
			if (::fetestexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID))
				return 0; // Fast reject in case of under/overflow


					 // Almost static filter
			double fa11 = fabs(a11);
			double fa21 = fabs(a21);
			double fa31 = fabs(a31);
			double fa12 = fabs(a12);
			double fa22 = fabs(a22);
			double fa32 = fabs(a32);
			double fa13 = fabs(a13);
			double fa23 = fabs(a23);
			double fa33 = fabs(a33);
			double fax = fabs(ax);
			double fay = fabs(ay);
			double faz = fabs(az);
			double fbx = fabs(bx);
			double fby = fabs(by);
			double fbz = fabs(bz);
			double fcx = fabs(cx);
			double fcy = fabs(cy);
			double fcz = fabs(cz);
			double fpxrx = fabs(px_rx);
			double fpyry = fabs(py_ry);
			double fpzrz = fabs(pz_rz);

			double max1, max2, max3, max4, max5, max6, max7, max8;
			max4 = fa11;
			if (max4 < fa31) max4 = fa31;
			if (max4 < fa21) max4 = fa21;
			max5 = max4;
			if (max5 < fpxrx)  max5 = fpxrx;
			max1 = max5;
			if (max1 < fbx) max1 = fbx;
			if (max1 < fax) max1 = fax;
			if (max1 < fcx) max1 = fcx;
			max2 = fbz;
			if (max2 < faz) max2 = faz;
			if (max2 < fcz) max2 = fcz;
			if (max2 < fa13) max2 = fa13;
			max6 = fa12;
			if (max6 < fa22) max6 = fa22;
			if (max6 < fa32) max6 = fa32;
			max3 = max6;
			if (max3 < fay) max3 = fay;
			if (max3 < fcy) max3 = fcy;
			if (max3 < fby) max3 = fby;
			if (max3 < fpyry) max3 = fpyry;
			max7 = fa13;
			if (max7 < fa23) max7 = fa23;
			if (max7 < fa33) max7 = fa33;
			max8 = max7;
			if (max8 < fpzrz) max8 = fpzrz;

			double eps = 3.5376137154540446e-011 * max6 * max7 * max4 * max1 *
				max6 * max7 * max4 * max3 * max3 * max8 * max5 * max2;
			//if ((det4x4_return_value > eps)) return (d > 0) ? (1) : (-1);
			//if ((det4x4_return_value < -eps)) return (d > 0) ? (-1) : (1);
			if ((det4x4_return_value > 0)) return (d > 0) ? (1) : (-1);//changed
			if ((det4x4_return_value < 0)) return (d > 0) ? (-1) : (1);//changed
			return 0;
		}

		static inline int orient3D_LPI_Original(double px, double py, double pz,
				double qx, double qy, double qz,
				double rx, double ry, double rz,
				double sx, double sy, double sz,
				double tx, double ty, double tz,
				double ax, double ay, double az,
				double bx, double by, double bz,
				double cx, double cy, double cz)
			{
				::feclearexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID);

				double a11, a12, a13, a21, a22, a23, a31, a32, a33;
				double px_rx, py_ry, pz_rz;
				double a2233, a2133, a2132;
				double d, n;
				double dax, day, daz, dbx, dby, dbz, dcx, dcy, dcz;
				double ix, iy, iz;
				double m12, m13, m14, m23, m24, m34;
				double m123, m124, m134, m234;
				double det4x4_return_value;

				a11 = (px - qx);
				a12 = (py - qy);
				a13 = (pz - qz);
				a21 = (sx - rx);
				a22 = (sy - ry);
				a23 = (sz - rz);
				a31 = (tx - rx);
				a32 = (ty - ry);
				a33 = (tz - rz);
				px_rx = px - rx;
				py_ry = py - ry;
				pz_rz = pz - rz;
				a2233 = ((a22 * a33) - (a23 * a32));
				a2133 = ((a21 * a33) - (a23 * a31));
				a2132 = ((a21 * a32) - (a22 * a31));
				d = (((a11 * a2233) - (a12 * a2133)) + (a13 * a2132));
				n = ((((py_ry)* a2133) - ((px_rx)* a2233)) - ((pz_rz)* a2132));
				ix = ((d * px) + (a11 * n));
				iy = ((d * py) + (a12 * n));
				iz = ((d * pz) + (a13 * n));
				dax = d * ax;
				day = d * ay;
				daz = d * az;
				dbx = d * bx;
				dby = d * by;
				dbz = d * bz;
				dcx = d * cx;
				dcy = d * cy;
				dcz = d * cz;
				m12 = ((dax * iy) - (ix * day));
				m13 = ((dbx * iy) - (ix * dby));
				m14 = ((dcx * iy) - (ix * dcy));
				m23 = ((dbx * day) - (dax * dby));
				m24 = ((dcx * day) - (dax * dcy));
				m34 = ((dcx * dby) - (dbx * dcy));
				m123 = (((m23 * iz) - (m13 * daz)) + (m12 * dbz));
				m124 = (((m24 * iz) - (m14 * daz)) + (m12 * dcz));
				m134 = (((m34 * iz) - (m14 * dbz)) + (m13 * dcz));
				m234 = (((m34 * daz) - (m24 * dbz)) + (m23 * dcz));
				det4x4_return_value = (m234 - m134 + m124 - m123);
				if (::fetestexcept(FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID))
					return 0; // Fast reject in case of under/overflow


						 // Almost static filter
				double fa11 = fabs(a11);
				double fa21 = fabs(a21);
				double fa31 = fabs(a31);
				double fa12 = fabs(a12);
				double fa22 = fabs(a22);
				double fa32 = fabs(a32);
				double fa13 = fabs(a13);
				double fa23 = fabs(a23);
				double fa33 = fabs(a33);
				double fax = fabs(ax);
				double fay = fabs(ay);
				double faz = fabs(az);
				double fbx = fabs(bx);
				double fby = fabs(by);
				double fbz = fabs(bz);
				double fcx = fabs(cx);
				double fcy = fabs(cy);
				double fcz = fabs(cz);
				double fpxrx = fabs(px_rx);
				double fpyry = fabs(py_ry);
				double fpzrz = fabs(pz_rz);

				double max1, max2, max3, max4, max5, max6, max7, max8;
				max4 = fa11;
				if (max4 < fa31) max4 = fa31;
				if (max4 < fa21) max4 = fa21;
				max5 = max4;
				if (max5 < fpxrx)  max5 = fpxrx;
				max1 = max5;
				if (max1 < fbx) max1 = fbx;
				if (max1 < fax) max1 = fax;
				if (max1 < fcx) max1 = fcx;
				max2 = fbz;
				if (max2 < faz) max2 = faz;
				if (max2 < fcz) max2 = fcz;
				if (max2 < fa13) max2 = fa13;
				max6 = fa12;
				if (max6 < fa22) max6 = fa22;
				if (max6 < fa32) max6 = fa32;
				max3 = max6;
				if (max3 < fay) max3 = fay;
				if (max3 < fcy) max3 = fcy;
				if (max3 < fby) max3 = fby;
				if (max3 < fpyry) max3 = fpyry;
				max7 = fa13;
				if (max7 < fa23) max7 = fa23;
				if (max7 < fa33) max7 = fa33;
				max8 = max7;
				if (max8 < fpzrz) max8 = fpzrz;

				double eps = 3.5376137154540446e-011 * max6 * max7 * max4 * max1 *
					max6 * max7 * max4 * max3 * max3 * max8 * max5 * max2;
				if ((det4x4_return_value > eps)) return (d > 0) ? (1) : (-1);
				if ((det4x4_return_value < -eps)) return (d > 0) ? (-1) : (1);
				return 0;
			}
			// template<typename T>
			// static T determinant(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, 0, 3, 3> &mat)
			// {
			// 	assert(mat.rows() == mat.cols());

			// 	if (mat.rows() == 1)
			// 		return mat(0);
			// 	else if (mat.rows() == 2)
			// 		return mat(0, 0) * mat(1, 1) - mat(0, 1) * mat(1, 0);
			// 	else if (mat.rows() == 3)
			// 		return mat(0, 0)*(mat(1, 1)*mat(2, 2) - mat(1, 2)*mat(2, 1)) - mat(0, 1)*(mat(1, 0)*mat(2, 2) - mat(1, 2)*mat(2, 0)) + mat(0, 2)*(mat(1, 0)*mat(2, 1) - mat(1, 1)*mat(2, 0));

			// 	assert(false);
			// 	return T(0);
			// }


	
	};
}
